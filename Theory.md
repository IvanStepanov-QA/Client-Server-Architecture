Что такое клиент? Приведи пример, что может быть клиентом.
> Это устройство, программа или приложение, которое запрашивает услуги или ресурсы у другого устройства, называемого сервером. Клиенты могут быть как аппаратными, так и программными. Например, веб-браузер может выступать в роли клиента, запрашивая веб-страницы у веб-сервера. Клиенты могут взаимодействовать с серверами через сетевые протоколы, такие как HTTP, FTP и другие.

Что такое сервер? Приведи пример, что может быть сервером сервера.
> Это компьютерная система или программа, которая предоставляет услуги, ресурсы или данные клиентам через сеть. Серверы могут быть физическими устройствами или виртуальными, работающими в облачной инфраструктуре. Они обрабатывают запросы клиентов, предоставляют запрашиваемые ресурсы, такие как файлы, веб-страницы или базы данных, и часто поддерживают многопользовательский доступ, позволяя множеству клиентов взаимодействовать с ними одновременно. Примеры типов серверов включают веб-серверы, файловые серверы, базы данных и почтовые серверы. 

Что такое Interface? Приведи пример.
> Интерфейс — это граница между двумя функциональными системами, на которой происходит их взаимодействие и обмен информацией. При этом процессы внутри каждой из систем скрыты друг от друга.  
С помощью интерфейса можно использовать возможности разных систем, не задумываясь о том, как они обрабатывают наши запросы и что у них «под капотом».  
Например, чтобы позвонить, не обязательно знать, как смартфон обрабатывает нажатия на тачскрин. Важно лишь, что в гаджете есть «кнопка», которая всегда возвращает одинаковый результат в ответ на определённые действия.  
Точно так же с помощью вызовов API можно выполнить определённые функции программы, не зная, как она работает. Поэтому API и называют интерфейсом.

Что такое толстый клиент? Приведи реальный пример, когда клиент считается толстым.
> Толстый клиент — это приложение, которое выполняет значительную часть обработки данных на стороне клиента. Это означает, что толстый клиент может работать независимо от сервера, обеспечивая большую функциональность и производительность. Большая часть логики, обработки и вычислений происходит на клиентском устройстве, а сервер обычно используется для хранения данных и управления ими. Например онлайн игра.

Что  такое тонкий клиент? Приведи реальный пример, когда клиент считается тонким.
> Тонкий клиент — это клиентское приложение, которое зависит от сервера для выполнения большей части своей обработки и функциональности. В отличие от толстого клиента, тонкий клиент минимален по функциям и не хранит значительное количество данных или логики. Обычно тонкие клиенты работают в веб-браузерах или в легких настольных приложениях и выполняют основную обработку на сервере, что позволяет им иметь меньшие системные требования. Примеры тонких клиентов включают веб-приложения и системы, работающие по модели SaaS (Software as a Service), такие как Google Docs.

Какие бывают уровни клиент серверной архитектуры?
>Уровень клиента – программное приложение, веб-браузер или устройство, которое отправляет запросы на сервер и получает ответы;  
>Уровень сервера – компьютер, физическая или виртуальная машина, которая обрабатывает запросы и отправляет ответы;  
>Уровень базы данных – система СУБД – принимает запросы для выполнения операций, хранит информацию, обеспечивает ее безопасность, целостность.  
> * Одноуровневая архитектура: Клиент напрямую взаимодействует с сервером. Простейший случай, часто встречающийся в небольших приложениях.
> * Двухуровневая архитектура: Клиент и сервер разделены на два уровня. Клиентский уровень отвечает за пользовательский интерфейс, а серверный — за обработку данных и логику приложения.
> * Трехуровневая архитектура: Включает три уровня — клиентский, сервер приложений (где выполняется бизнес-логика) и сервер данных (БД). Часто используется в крупных корпоративных приложениях.
> * Многоуровневая архитектура: Включает более трех уровней. Например, может быть уровень веб-сервера, сервер приложений, сервер базы данных и уровни для внешних сервисов и API. Такая архитектура обеспечивает лучшую масштабируемость и распределение нагрузки.  
> * Микросервисная архитектура (Microservices Architecture) — в этой более современной архитектуре приложения разбиваются на небольшие, независимые сервисы, каждый из которых реализует отдельную функциональность и взаимодействует с другими через API. Её основной плюс — гибкость, возможность независимого развёртывания и масштабирования сервисов.

Что такое балансировщик нагрузки (балансировщики)?  
> Балансировщик нагрузки — это устройство или программное обеспечение, которое распределяет входящий трафик между несколькими серверами. Это позволяет оптимизировать использование ресурсов, увеличить производительность и обеспечить отказоустойчивость системы. Другая важная функция балансировщика — защита от DDoS-атак. Ее обеспечивает задержка ответа, когда фоновые серверы не видят клиента до подтверждения по TCP  

Горячий резерв серверов? Холодный резерв серверов? Приведи реальный пример.  
> * Горячий резерв: Это система, где один сервер работает в активном режиме, а второй находится в режиме ожидания и готов немедленно взять на себя функции основного сервера в случае сбоя. Сервер в режиме горячего резерва может выполнять запросы на чтение и поддерживать актуальные данные.  
> * Холодный резерв: В этом случае резервный сервер находится в неактивном состоянии и не готов к немедленному переключению. Включение холодного резерва требует времени, что может привести к потере данных или функциональности во время переключения.  

Чем web service отличается от web server? Приведи пример.
> * **Web Server (веб-сервер)**:  это программа или устройство, которое хранит веб-страницы и отвечает на запросы клиентов (обычно браузеров). Он отправляет запрашиваемые страницы или файлы пользователям через интернет. Веб-сервер может размещать веб-сайты, обрабатывать запросы на доступ к статическому контенту (HTML, изображения и т.д.) и передавать их обратно пользователям.  
> * **Web Service (веб-сервис)**: это программное обеспечение, которое позволяет обмениваться данными между различными системами через интернет. Например, это API (интерфейс программирования приложений), который позволяет одной программе запрашивать информацию от другой. Веб-сервисы позволяют программам взаимодействовать друг с другом, независимо от языка программирования или платформы.

Что такое микросервисная архитектура? Приведи реальный пример использования.  
> Микросервисная архитектура — это стиль разработки программного обеспечения, в котором приложение делится на небольшие, самостоятельные сервисы. Каждый микросервис выполняет конкретную задачу и может быть разработан и развернут независимо от других. Это позволяет улучшить масштабируемость и гибкость системы.  

> Пример микросервисной архитектуры на реальном продукте — Netflix.  
Основные микросервисы:  
> * Сервис аутентификации: управляет логином и регистрацией пользователей.  
> * Сервис рекомендаций: предлагает фильмы на основе предпочтений пользователя.  
> * Сервис каталогов: хранит информацию о контенте (фильмы, сериалы).  
> * Сервис потоковой передачи: доставляет контент пользователям.  
> * Сервис платежей: обрабатывает подписки и платежи.  
> * Сервис мониторинга: отслеживает состояние других сервисов.  

Прокси сервер? Приведи пример.
> Прокси-сервер (от английского слова «proxy» — полномочие действовать от имени другого лица) — это программа, работающая на каком-либо компьютере в сети, позволяющая одним компьютерам, выполнять запросы к другим, от своего имени.  
Вот несколько примеров использования прокси-серверов:  
> * Web-прокси: Позволяет пользователям анонимно серфить в интернете. Например, сервисы вроде HideMyAss или KProxy позволяют пользователям получить доступ к заблокированным сайтам, скрывая их IP-адрес.  
> * Кэширование прокси: Ускоряет доступ к часто запрашиваемым ресурсам, например, Squid. Он хранит копии статических ресурсов и, когда клиент запрашивает эти ресурсы, они отдаются из кэша, вместо того чтобы запрашивать их с оригинального сервера.  
> * Обратный прокси: Используется для балансировки нагрузки и безопасности. Примером является Nginx, который может принимать запросы от клиентов и перенаправлять их на разные серверы, тем самым распределяя нагрузку.  
> * SOCKS-прокси: Подходит для обработки различных типов трафика (HTTP, FTP, SMTP и др.). Пример — SOCKS5, который обеспечивает анонимность и может использоваться для обхода блокировок.  
> * Прокси для контроля доступа: Используется в компаниях для фильтрации интернет-трафика и контроля доступа к ресурсам. Например, прокси-сервисы, такие как Zscaler, помогают управлять безопасностью и соблюдением политик.  

> Пример: Компания "ABC Corp" устанавливает прокси-сервер для управления доступом своих сотрудников к интернет-ресурсам.  

VPN? Приведи пример.  
> VPN (Virtual Private Network) — это технология, создающая защищенное и зашифрованное соединение между устройством пользователя и сетью, позволяя безопасно передавать данные через общественные сети. VPN скрывает реальный IP-адрес пользователя, обеспечивая анонимность и доступ к контенту, который может быть ограничен по географическому положению. Основные функции VPN включают:  
> * Шифрование: Защищает данные от перехвата.  
> * Анонимность: Скрывает реальный IP-адрес.  
> * Обход блокировок: Позволяет доступ к заблокированным ресурсам.  
> * VPN используется для повышения безопасности и конфиденциальности в интернете.  
> Пример: Журналисты и активисты используют VPN для безопасного общения и доступа к информации без отслеживания.  

Что такое атака Man-in-the-Middle?  
> Атака "Man-in-the-Middle" (MITM) — это тип кибератаки, при которой злоумышленник тайно перехватывает и изменяет коммуникацию между двумя сторонами, которые думают, что общаются напрямую друг с другом.  
Пример: Представь, что ты отправляешь сообщение другу. Злоумышленник перехватывает это сообщение, изменяет его и отправляет другу, при этом оба вы думаете, что общаетесь напрямую. Злоумышленник может получить доступ к конфиденциальной информации, такой как пароли или банковские данные.

Что такое API?  
> API (англ. application programming interface — программный интерфейс приложения) — это набор способов и правил, по которым различные программы общаются между собой и обмениваются данными.
Все эти взаимодействия происходят с помощью функций, классов, методов, структур, а иногда констант одной программы, к которой обращаются другие. Это основной принцип работы API.  

Что такое REST API?
> REST API (Representational State Transfer)- является наиболее распространенным типом API в клиент-серверной архитектуре и имеет ряд свойств — например, отсутствие хранения состояния и кэшируемость. REST API построен на стандартных протоколах HTTP и обычно возвращает данные в формате JSON, хотя может поддерживать и другие форматы.  
REST API использует стандартные HTTP-методы для взаимодействия, включая GET, POST, PUT, DELETE и другие. Каждый метод соответствует определенному типу действий, которые могут быть выполнены над ресурсами API.
Простота и гибкость REST API сделали его лучшим выбором для многих разработчиков, но при работе с большими объемами данных он может быть неэффективными, так как для получения всех необходимых данных может требоваться несколько запросов.

Требования к архитектуре Rest.  
> Всего в REST есть шесть требований к проектированию API. Пять из них обязательные, одно — опциональное:  
> * Клиент-серверная модель (client-server model).  
Это требование отделяет друг от друга два понятия: клиент и сервер. Получается структура, при которой клиент направляет к серверу запрос, а в ответ получает ресурсы. Такое разделение позволяет создавать клиент и сервер независимо друг от друга, что ускоряет и упрощает разработку.  
> * Отсутствие состояния (statelessness).  
На сервере не хранится никаких данных о прошлых взаимодействиях с клиентом — каждый запрос должен содержать всю информацию для его обработки.
> * Кэширование (cacheability).  
Поскольку API без сохранения состояния может увеличить накладные расходы на запросы, управляя огромными нагрузками входящих и исходящих вызовов, дизайн REST API должен хранить кэшируемые данные. Согласно этому принципу проектирования API, данные в ответе должны быть косвенно или классифицированы как кэшируемые или некэшируемые. Если ответ кэшируется, кэшу клиента предоставляется право повторно использовать эти данные ответа для аналогичных запросов в будущем.  
> * Единообразие интерфейса (uniform interface).  
Чтобы отделить клиент от сервера, вам необходимо иметь единый интерфейс, который позволяет автономно разрабатывать приложение без жесткой привязки его сервисов, моделей и действий к самому уровню API. Этот принцип проектирования оптимизирует всю архитектуру системы и повышает наглядность. коммуникаций.Некоторые архитектурные элементы управления требуют управления производительностью элементов в архитектуре REST API для достижения единообразного интерфейса. Архитектура REST API определяет принципы REST с помощью четырех элементов управления интерфейсом, включая идентификацию ресурсов, управление ресурсами посредством представлений, обеспечение самоописательной связи и превращение гипермедиа в механизм состояния приложения.  
> * Многоуровневая система (layered system).  
До сих пор мы рассматривали сервер как единую сущность. Но его структура куда сложнее. Между ним и клиентом есть несколько промежуточных узлов, выполняющих вспомогательные функции, — прокси-серверы.
Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных.  
> * Код по требованию (code on demand) — необязательно.  
Этот принцип означает, что сервер в ответ на запрос может отправить исходный код, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.

Что такое CRUD?  
> CRUD — это аббревиатура, которая обозначает четыре основных операции, выполняемых с базами данных или другими хранилищами данных. Эти операции используются для управления данными в приложениях и сервисах.
Create - Read - Update - Delete  

Чем GET отличается от POST?  
> * GET — запрашивает данные с сервера. Метод работает только на чтение, поэтому он безопасен и идемпотентен.  
> * POST — метод для создания новых данных на сервере. Он не идемпотентный, поскольку повторные запросы могут привести к созданию нескольких копий одного и того же ресурса. POST небезопасный метод, так как может модифицировать существующие данные.  

> Основное отличие метода GET от POST в способе передачи данных.
Запрос GET передает данные в URL в виде пар "имя-значение" (другими словами, через ссылку), а запрос POST передает данные в теле запроса. 

Чем POST отличается от PUT?  
> PUT — метод для регулярного обновления данных на сервере. PUT обновляет всю запись целиком. Идемпотентен и небезопасен. 
POST идеально подходит для создания новых ресурсов без указания их URI, что делает его универсальным для добавления нескольких записей. PUT, с другой стороны, подходит для создания или обновления ресурсов по определенному URI, обеспечивая идемпотентность. 


Чем PUT отличается от PATCH?  
> PATCH — используется для частичного обновления ресурса на сервере. В отличие от PUT, PATCH применяется только к изменяемым частям ресурса, не затрагивая другие. Не является идемпотентным и безопасным с точки зрения стандарта HTTP.  
Запрос PATCH является набором инструкций о том, как изменить ресурс. 
В отличие от PUT, который полностью заменяет ресурс.  

Можно ли в POST передать данные и через URL и через Body?  
> Да, в POST-запросе данные могут быть переданы как через URL (в строке запроса), так и через тело запроса (body). Однако это не является обычной практикой и может запутать обработку запроса на сервере
Рекомендуется:  
> * Передавать параметры, которые не меняют состояние сервера (например, фильтры, ключи), через URL.  
> * Передавать данные, которые создают или изменяют ресурс, через тело запроса.  

Можно ли с помощью URLa передать данные на сервер?  
> Это делается с помощью строки запроса (query parameters). Строка запроса начинается после символа ? в URL и состоит из пар "ключ=значение", разделенных символом &.  

Что такое идемпотентность?  
> Идемпотентность запроса — это обеспечение возможности многократного вызова запроса с гарантией того, что состояние системы изменится только один раз.  
Идемпотентными методами являются: GET, PUT, DELETE, HEAD и OPTIONS.  

В чем разница между безопасностью и идемпотентностью?  
> Основные отличия между безопасностью и идемпотентностью:  
> * Безопасность касается того, что запрос не изменяет состояние сервера. Это свойство присуще методам, которые предназначены только для получения информации (например, GET).  
> * Идемпотентность касается того, что результат будет одинаковым при многократном выполнении запроса. Даже если запрос изменяет данные на сервере, повторный вызов приведёт к тому же состоянию.  

> Пример различия:  
GET безопасен и идемпотентен: запрос не изменяет сервер и при повторном вызове даёт один и тот же результат.  
PUT идемпотентен, но не безопасен: первый вызов изменяет данные на сервере (небезопасен), но повторные вызовы с теми же данными не изменят состояние сервера (идемпотентен).  
POST не безопасен и не идемпотентен: первый вызов создаёт новый ресурс, повторный вызов может создать другой ресурс (например, другой объект с уникальным ID).  

Что такое endpoint?  
> Endpoint — это конкретный URL-адрес, по которому клиенты могут обращаться к ресурсу или сервису через API. Он определяет точку доступа для взаимодействия с сервером, отправки запросов и получения ответов.  
Пример: Если у вас есть API для управления пользователями, один из эндпоинтов может быть: https://api.example.com/users. Запросы к этому URL позволят получать список пользователей или добавлять новых.

Что такое статус код сервера?  
> Код состояния HTTP (англ. HTTP status code) — часть первой строки ответа сервера при запросах по протоколу HTTP. Эти статус коды предоставляют важную информацию о состоянии запроса и ответа, которые являются критическими для понимания взаимодействия между клиентом и сервером.  
Код статуса представляет собой ответ сервера, который состоит из трёх цифр. Первая определяет класс ответа, а две другие указывают конкретный ответ. Ответы HTTP разделяются на пять классов, каждый из которых имеет свои уникальные особенности и значения. 

Какие существуют группы?  
> * Информационные 100-199 — означают, что запрос браузера принят и проходит обработку
> * Успешные 200-299 — говорят о том, что запрос обработан и информация передана браузеру
> * Перенаправление 300-399 — подразумевают собой, что браузер получает не то, что хотел пользователь
> * Ошибка на стороне клиента 400-499
> * Ошибка на стороне сервера 500-599.

Какие ты знаешь 5 из 400?  
> * 400 — Bad Request. Сервер не разобрал запрос пользователя из-за синтаксической ошибки. Указывает, что сервер не смог обработать запрос из-за ошибки на стороне клиента. Причины: неверный формат данных, отсутствие необходимых параметров или ошибки в синтаксисе. Код 400 сигнализирует клиенту, что запрос нужно исправить и отправить повторно.
> * 401 — Unauthorized. Сообщает о том, что для доступа к информации нужно быть авторизованным. Сервер требует аутентификации для доступа к запрашиваемому ресурсу. Этот код часто используется для защищенных страниц или API, где нужно подтвердить личность пользователя.
> * 402 — Payment Required. Предусмотрен для платных пользовательских сервисов и означает, что плата за услуги просрочена. Не касается хостинговых провайдеров.
> * 403 — Forbidden. Ошибка сообщает о том, что доступ к данной странице запрещен или не может быть предоставлен сервером. Причины: ограничение доступа, заблокированные IP-адресами или политика безопасности.
> * 404 — Not Found. Это одна из самых распространенных ошибок, возникающая, когда страница была удалена, перемещена или адрес введен неверно.
> * 405 — Method Not Allowed. Означает, что в запросе указан неподдерживаемый сервером метод.  

Какие ты знаешь 5 из 500?  
> * 500 — Internal Server Error. На сервере произошла непредвиденная ошибка или аварийный отказ.Это может быть связано с ошибками в коде, проблемами с серверным программным обеспечением или некорректной конфигурацией.
> * 501 — Not Implemented. У сервера нет необходимых возможностей, для того чтобы обработать запрос.Наиболее распространенные причины возникновения: вирусы или другое вредоносное программное обеспечение, которые контролируют ваш интернет-браузер;сервер, обрабатывающий запросы, перегружен запросами;ошибка сервера, обрабатывающего запросы;наименее вероятная причина — устаревшее программное обеспечение сервера.
> * 502 — Bad Gateway. Запрос пользователя отправляется к серверу, но тот сопряжен еще с несколькими серверами, между которыми образуется цепочка. В одном из серверов цепочки может произойти сбой, и первый сервер выдает данную ошибку.
> * 503 — Service Unavailable. Сервер временно перестал работать. Вместе с ошибкой может появиться параметр Retry-After, его значение показывает через какое время можно повторить попытку зайти на данный ресурс.
> * 504 — Gateway Time-out. Указывает на то, что сервер, действующий как шлюз или прокси, не получил своевременный ответ от вышестоящего сервера. Это может быть связано с перегрузкой, сетевыми проблемами или недоступностью ресурса.
> * 505 — HTTP Version not supported. Указанный в запросе протокол HTTP сервер не поддерживает или отказывается работать с данной версией протокола.  

Какие ты знаешь Headers в Request?  
> HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.  
В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:  
> * Общего назначения, которые применяются ко всему сообщению целиком.  
> * Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.  
> * Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.  

> Самые частые заголовки запроса:
> * **Host** Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.
> * **User-Agent** Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.
> * **Refer** Используется для указания того, откуда поступил текущий запрос. Например, если вы решите перейти по какой-нибудь ссылке в этой статье, то вероятнее всего к запросу будет добавлен заголовок Refer.
> * **Accept** Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (‘ , ‘). А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.
> * **Cookie** Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.
> * **Authorization** Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.  

Какие ты знаешь Headers в Responce?  
> Заголовки (Headers) в HTTP-ответе передают информацию о сервере и ответе на запрос клиента. Вот некоторые из ключевых заголовков:
> * Content-Type: Указывает тип данных, возвращаемых сервером.
> * Content-Length: Указывает размер тела ответа в байтах.
> * Date: Дата и время, когда был отправлен ответ.
> * Server: Информация о сервере, который обработал запрос.
> * Set-Cookie: Устанавливает куки на стороне клиента.
> * Cache-Control: Управляет кэшированием ответа.
> * ETag: Уникальный идентификатор версии ресурса, используется для кэширования.
> * Location: Указывает URL для перенаправления клиента.
> * Content-Encoding: Указывает метод сжатия данных.
> * Allow: Указывает методы HTTP, которые поддерживаются для конкретного ресурса.  

Из чего состоит запрос HTTP - реквест?
> HTTP-запрос состоит из нескольких ключевых компонентов:
> #### Стартовая строка
> * Метод: Тип запроса (GET, POST, PUT, DELETE и т.д.).
> * URI: Унифицированный идентификатор ресурса (URL).
> * Версия протокола: Версия HTTP (например, HTTP/1.1).  
> #### Заголовки (Headers):
> * Передают метаинформацию о запросе, клиентах и содержимом.
> * Примеры заголовков: Host, Content-Type, User-Agent, Accept.
> #### Тело запроса (Body) (не всегда присутствует):
> * Содержит данные, которые отправляются на сервер (например, JSON, XML, файлы).
> * Обычно используется в методах POST и PUT.
> #### Строка запроса (Query Parameters) (не всегда присутствует):
* Дополнительные параметры, передаваемые в URL.  

Из чего состоят ответы HTTP -респонс?
> HTTP-ответ (респонс) состоит из нескольких ключевых компонентов:
> #### Стартовая строка (Status Line):
> * Версия протокола: Версия HTTP (например, HTTP/1.1).
> * Код состояния (Status Code): Числовой код, указывающий на результат обработки запроса (например, 200, 404).
> * Сообщение состояния (Reason Phrase): Краткое описание кода состояния (например, OK, Not Found).  
> #### Заголовки (Headers):
> * Метаинформация о сервере и ответе.
> * Примеры заголовков: Content-Type, Content-Length, Server.  
> #### Тело ответа (Body) (не всегда присутствует):
> * Содержит данные, возвращаемые сервером (например, HTML, JSON, изображения).
> * Обычно используется для передачи основного контента.  

Что такое и какая разница, Идентификация, Аутентификация, Авторизация?
> * Идентификация — это процесс, при котором система определяет, кто именно пытается получить доступ к ее ресурсам. Пользователь сообщает системе свою идентификационную информацию, например, логин или идентификационный номер.  
> * Аутентификация — это процесс проверки подлинности предоставленных учетных данных, чтобы подтвердить, что пользователь действительно тот, за кого себя выдает. Обычно это достигается с помощью пароля, но может также включать биометрические данные, двухфакторную аутентификацию и т.д.  
> * Авторизация — это процесс определения прав и уровней доступа пользователя к ресурсам после успешной аутентификации. Авторизация определяет, какие действия пользователь может выполнять и к каким данным иметь доступ.  

> Пример: Когда ты вводишь логин или номер телефона на сайте, ты идентифицируешь себя системе.  
Когда ты вводишь пароль после ввода логина, система аутентифицирует тебя, проверяя, что пароль правильный.  
После успешной аутентификации система проверяет, какие страницы и функции доступны тебе на основании твоих прав доступа, например, администратор может изменять настройки, а обычный пользователь — только просматривать данные.  

Что происходит при валидации на сервере?
> Валидация на сервере — это процесс проверки данных, отправленных с клиента, чтобы убедиться, что они соответствуют ожидаемым параметрам, и предотвратить возможные ошибки или атаки. Вот как это обычно работает:
> * Получение данных: Сервер получает данные от клиента (например, через HTTP-запрос).
> * Проверка структуры данных: Сервер проверяет, что данные соответствуют ожидаемой структуре. Например, если ожидается JSON-объект, сервер проверяет, что данные являются корректным JSON.
> * Проверка типов данных: Сервер проверяет, что значения данных соответствуют ожидаемым типам (например, число, строка, дата).
> * Проверка обязательных полей: Убедиться, что все необходимые поля присутствуют и не пусты.
> * Проверка форматов: Проверка, что данные соответствуют определённым форматам (например, адрес электронной почты, номер телефона).
> * Проверка логики и бизнес-правил: Сервер проверяет данные на соответствие бизнес-правилам и логике приложения (например, возраст пользователя должен быть больше 18 лет).
> * Обработка ошибок: Если данные не проходят валидацию, сервер возвращает сообщение об ошибке клиенту с указанием, какие именно данные неверны.
> * Сохранение данных: Если данные проходят все проверки, сервер сохраняет их в базе данных или выполняет другие операции.
> * Ответ клиенту: Сервер отправляет ответ клиенту, подтверждающий успешную обработку данных или информирующий об ошибках.

Что происходит при валидации на клиенте?
> Процесс валидации на клиенте — это проверка данных прямо в браузере или приложении пользователя перед отправкой на сервер. Это помогает выявить ошибки и дать пользователю возможность исправить их на месте, снижая нагрузку на сервер и улучшая пользовательский опыт.
> Основные шаги валидации на клиенте:
> * Получение данных: Пользователь вводит данные в формы или другие элементы ввода.
> * Проверка структуры данных: Проверка, что данные соответствуют ожидаемому формату и структуре.
> * Проверка типов данных: Проверка, что данные имеют правильные типы (например, строка, число).
> * Проверка обязательных полей: Убедиться, что все обязательные поля заполнены.
> * Проверка форматов: Проверка, что данные соответствуют определённым форматам.
> * Проверка длины: Проверка, что данные соответствуют допустимой длине.
> * Визуальные уведомления: Отображение ошибок и уведомлений пользователю в реальном времени.
> * Отправка данных: Если данные проходят валидацию, они отправляются на сервер.

Что такое токен?
> Токен — это строка данных, которая используется для аутентификации и авторизации в системах. Он может представлять собой временный код, который удостоверяет личность пользователя или приложения и предоставляет доступ к определенным ресурсам или услугам.

Где хранится токен?
>Токены генерируются на сервере на основе секретного ключа и payload, и могут храниться на сервере или передаваться клиенту для использования в запросах.  
Основные методы хранения токенов включают:
> * Local Storage:  
Токены хранятся в браузерном локальном хранилище. Этот метод удобен, но уязвим для XSS-атак.
> * Session Storage:  
Подобно Local Storage, но данные хранятся только в течение текущей сессии. При закрытии вкладки или браузера данные удаляются.
> * Cookies:  
Токены могут храниться в HTTP-куки, которые могут быть настроены с атрибутами HttpOnly и Secure, что повышает безопасность, так как доступ к ним из JavaScript ограничен.
> * Memory (в оперативной памяти):  
Некоторые приложения хранят токены временно в памяти. Этот метод защищает данные от XSS, но токены теряются при перезагрузке страницы или обновлении приложения.
> * Secure Storage (для мобильных приложений):  
На мобильных устройствах токены могут храниться в защищенных хранилищах, таких как Keychain на iOS или Keystore на Android.

Что такое токен авторизации? Объясни процесс токен авторизации?
> Токен авторизации — это специальный код или устройство, которое используется для подтверждения вашей личности в системах безопасности.  
Он может быть физическим (например, ключ, который вставляется в компьютер) или программным (например, код, отправленный на телефон).  
Токен позволяет получать доступ к различным ресурсам, подтверждая, что вы действительно тот, кем себя выдаете.
Токен авторизации работает следующим образом:
> 1. Аутентификация пользователя:  Когда вы входите в систему (например, вводите логин и пароль), сервер проверяет ваши данные. Если они верны, сервер генерирует токен.
> 2. Генерация токена: Сервер создает токен — уникальную строку, которая содержит информацию о пользователе и сроке действия токена. Этот токен обычно подписывается (шифруется) для защиты от подделки.
> 3. Отправка токена клиенту: Токен отправляется вашему устройству (например, браузеру или мобильному приложению). Вы теперь можете использовать его для доступа к защищенным ресурсам.  
> 4. Использование токена: При каждом запросе к серверу вы отправляете этот токен в заголовках HTTP        или в качестве параметра. Это позволяет серверу идентифицировать вас и разрешить доступ к ресурсам без повторного ввода логина и пароля.
> 5. Проверка токена: Сервер принимает ваш запрос, проверяет токен на действительность и находит информацию о вас. Если токен действителен, доступ к ресурсу предоставляется.
> 6. Истечение срока действия: Токены имеют ограниченный срок действия для повышения безопасности. После его истечения вам может понадобиться выполнить повторную аутентификацию (например, снова ввести логин и пароль).  

Может ли быть авторизация без аутентификации? Приведи пример.
> Авторизация возможна и сама по себе, без идентификации или аутентификации. Примером может служить возможность публикации документов в Google Документах, когда доступ открыт для всех желающих. 
В этом случае владелец документа увидит уведомление о том, что документ просматривает анонимный пользователь. Несмотря на отсутствие идентификации, пользователь получает разрешение на чтение документа.
Если бы доступ к документу был ограничен определенными пользователями, то для получения доступа к чтению, анонимному пользователю потребовалось бы пройти идентификацию (ввести логин), аутентификацию (подтвердить свой пароль и временный код) и, наконец, авторизацию.  

Что такое куки?  
> Cookie (куки) — это небольшие текстовые файлы, сгенерированные сайтами. В них записана информация о посещении сайта. Эти файлы хранятся на компьютере.
Cookie нужны, чтобы идентифицировать пользователя. Когда вы вернётесь на сайт, он узнает вас и автоматически подстроится. Формы регистрации будут заполнены, языковые и региональные настройки заданы. Если на сайте вы выбирали товары, то новые будут предложены на основе ваших предпочтений.

Что такое теплый клиент?
> Тёплый клиент — это пользователь, который уже взаимодействовал с веб-сайтом или веб-приложением и для которого сохранены определенные данные, такие как куки, кэш и данные авторизации. Эти данные сохраняются в браузере или на устройстве и обеспечивают несколько важных преимуществ:  
1.Быстрая загрузка страницы  
2.Персонализация  
3.Упрощение аутентификации  
4.Повышение удобства работ  

Что такое холодный клиент?  
> Холодный клиент — это пользователь, который заходит на сайт впервые или недавно очистил кэш и куки. Для сайта такой клиент — "чистый лист", и работа с ним требует больше ресурсов:  
1.Длительная загрузка страниц  
2.Отсутствие персонализации  
3.Необходимость аутентификаци  
4.Неоптимизированный опыт  

Что такое кеш?
> Кэш — это память программы или устройства, которая сохраняет временные или часто используемые файлы для быстрого доступа к ним. Это увеличивает скорость работы приложений и операционной системы. Процесс сохранения таких файлов в специальном месте называется кэшированием.  
Кэш-память нужна, чтобы приложения и система работали быстрее. Также она:  
снижает нагрузку на основное хранилище;  
дает системе возможность выполнять больше действий одновременно;  
экономит трафик.  
Пример: Рассмотрим кэш браузера. Это папка с файлами, которые браузер загрузил в память устройства. В файлах могут быть видео, музыка, изображения или скрипты с какого-то сайта. Когда вы в следующий раз вернётесь на сайт, то браузер не будет запрашивать эти файлы, а возьмет их из кэша. Нужная вам страница загрузится быстрее.  

Для чего используется кэширование страниц?
> Кэширование страниц используется для оптимизации производительности и экономии ресурсов. Суть в том, что при посещении страницы ее содержимое сохраняется в кэше, и при следующем посещении можно загрузить кэшированную версию, вместо того чтобы запрашивать ресурсы с сервера.  
Для примера увидеть как кэшируются файлы, можно при просмотре онлайн-видео. Пока вы смотрите видеоролик, он загружается в кэш вашего устройства. Если видео загрузится полностью, его можно будет досмотреть даже с отключённым интернетом.  

Для чего необходимо сбрасывать кэш и куки?
> Сбрасывание кэша и куки необходимо для нескольких важных целей:
> #### Для чего необходимо сбрасывать кэш:
> * Свежие данные: Кэш может хранить устаревшую информацию. Сброс кэша гарантирует, что вы получаете самые последние версии страниц и ресурсов.
> * Исправление ошибок: Иногда кэшированные данные могут вызвать ошибки в отображении или функциональности сайта. Сброс кэша помогает устранить такие проблемы.
> * Очистка пространства: Кэш может занимать значительное количество дискового пространства. Регулярное очищение кэша освобождает место на вашем устройстве.
> #### Для чего необходимо сбрасывать куки:
> * Обновление авторизации: Куки могут содержать данные о сеансах и аутентификации. Сброс куки может помочь устранить проблемы с входом или выходом из аккаунта.
> * Устранение проблем с конфиденциальностью: Куки могут отслеживать вашу активность в интернете. Очистка куки помогает защитить вашу приватность.
> * Решение проблем с производительностью: Накопление большого количества куки может замедлить работу браузера. Очистка куки может улучшить производительность.  

Что такое сессия?
Какие стореджи браузера ты знаешь?
В чем разница между сешин сторедж и локал сторедж?
Что такое REST 
Что такое SOAP
Чем REST отличается от SOAP?
JSON Schema - это?
Что такое JSON и XML?
Каким форматом данных могут быть ключи в JSON?
Каким форматом данных могут быть значения в JSON?
Какие невалидные типы данных есть у JSON?
Что такое WSDL
Что такое WADL
Что такое логи?
Что такое логирование?
Перечислите типы логов
Механизм записи информации в логи
Зачем нужны логи? Какие инструменты знаете для сбора логов?
Привести примеры, когда QA-специалисту необходимо собрать логи с помощью Kibana
Что такое DNS?
Что такое IP адрес?
Что такое порт?
Что такое хост?
Что такое URL
В чем разница между URI, URL, URN ?
Из чего состоит url адрес?
Что происходит после ввода запроса в адресную строку?
Что такое HTTP?
Что такое HTTPS?
SSL и TLS - это?
TCP/IP - это?
Уровни TCP/IP?
Уровни OSI?
Что такое FTP?
Какую структуру имеет веб-страница?
Что такое HTML/CSS/JavaScript?
Что такое AJAX?
Что такое адаптивная и респонсивная верстка?
Как протестировать адаптивную верстку?
Как выполнить Debug страницы в браузере?
Что такое WebSocket и как проверить обрыв соединения?
Как узнать схему API проекта
Можно ли начать тестирование, если интерфейс (frontend) ещё не готов? Как?
Какие виды тестирования можно применить только к Web?
Каковы есть основные виды уязвимости веб-приложений?
Какие инструменты для тестирования Web performance client-side знаете?
